---
title: "US Metro Areas: Spatial and Statistical Analysis of Wellbeing"
author: "Grace, Rodrigo, Steedman and Mike"
date: "11/16/2020"
output:
  rmdformats::readthedown:
    thumbnails: false
    highlight: NULL
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, fig.align="center")
library(tidyverse)
library(rmdformats)
library(leaflet)
library(maps)
library(tidycensus)

```

[Link to old Shiny App](https://sjenkins23.shinyapps.io/metro_areas_1/?_ga=2.259223753.2139815388.1605468268-618769786.1599849958)

[Link to new Shiny App](https://sjenkins23.shinyapps.io/Metro_Areas/?_ga=2.21772920.2139815388.1605468268-618769786.1599849958)

## Background and Motivation



## Data

To answer our questions of interest and extend our midterm project, we returned to the ‘tidycensus’ package. Tidycensus is an R package that allows users to access data from the US Census Bureau’s decennial Census and American Community Survey. More information about the basics of working with the ‘tidycensus’ package can be found [here](https://walker-data.com/tidycensus/index.html). We referred to this resource often throughout our project to learn about the basic functions and capabilities of tidycensus.

For our midterm project, we pulled 2018 American Community Survey data for US metropolitan areas (check out our midterm Shiny App [here!](https://sjenkins23.shinyapps.io/metro_areas_1/?_ga=2.259223753.2139815388.1605468268-618769786.1599849958)). Transitioning to our final project, we decided to still focus on US metro areas, but further explore the possibilities of the ‘tidycensus’ package by pulling data from more years and adding new variables of interest. Our vision was to create blog components that would allow users to explore the change in ACS data over time. We also were interested in using variable change over time as a method to measure the ‘wellbeing’ of a city. 

As we started compiling our new dataset, we quickly found that American Community Survey data was only available for metro areas via ‘tidycensus’ from 2009 to 2018. Because of this limitation, we chose to focus on this specific time range for our project. The next step in our data collection process was to select and compile variables of interest for all of our different years and cities. Variables are encoded within tidycensus (i.e B01003_001 = population). Thus, in order to access data using the get_acs function, one must know the variable’s specific code. Very quickly, we found that some of the variables we used in our midterm project had different codes for different years, complicating our data collection process. Therefore, a large part of this section of our project became filtering through the ACS 2009 - 2018 data to find variables/variable codes that were consistent for all of the years. Eventually we compiled the following list: 

* population = "B01003_001"
* median_income = "B19326_001" 
* foreign_born = "B05002_013"
* median_value = "B25077_001"
* married_households = "B11001_003"
* total_households = "B11001_001"
* houses_for_sale = "B25004_004"
* pop_white_alone = "B02001_002"
* pop_black_alone = "B02001_003"
* median_age_female = "B01002_003"
* median_age_male = "B01002_002"
* under_poverty_line = "B10059_002"
* bachelors_degree = "B15003_022"

After collecting these variable codes, we used a for loop to compile the data from all of the different years. Using a for loop was a really convenient way for us to avoid having to individually compile and join datasets for each year. Although difficult to understand out of context, here is a snippet of our for loop code to get a sense of the process of obtaining data via tidycensus:

```{r, eval = FALSE}

for (i in 2013:2017){
  df <- get_acs(geography = geo, variables = vars, year = i)%>%
        pivot_wider(id_cols = NAME, 
                    names_prefix = paste0("y", i, "_"), 
                    names_from = variable, 
                    values_from = estimate)
  
  cities <- cities %>% left_join(df,
            by = "NAME")
}
```


Lastly, we knew we wanted to eventually create a leaflet map, so we joined our dataset with the mdsr WorldCities dataset to obtain latitude and longitude coordinates for our US metro areas. We had to hardcode coordinates for San Antonio, San Juan, Virginia Beach, and McAllen because they were not in the WorldCities dataset. Later, while we were creating the map, we realized some of the coordinates were wrong because we had joined the mdsr dataset by city name and some cities have the same name (i.e Portland, Oregon was showing up in Portland, Maine). We hardcoded to correct the instances with this issue.



## Findings

Explain features of the new Shiny App (links to old and new shiny app at the top of our rmd) and include a few interesting instances of map/model output.

```{r, echo=FALSE, message=FALSE}

map_data <- read_csv("map_data.csv") %>%
  filter(year == 2018)

mypal <- colorNumeric(
    palette = "OrRd",
    domain = map_data$median_age_male)

leaflet(map_data) %>% 
      addTiles() %>%
      setView(-97.5, 37.4, zoom = 3.5) %>%
      addCircleMarkers(lat= ~latitude
                       , lng= ~longitude
                       , popup= paste0(map_data$name_simp,", ", 
                                       map_data$state_abbrev, "<br>",
                                       "Median Age (Male)", 
                                       ": ", map_data$median_age_male)
                       , stroke = FALSE 
                       , radius = 7
                       , fillColor = mypal(map_data$median_age_male)
                       , fillOpacity = 1.0) %>%
      
      addLegend(pal = mypal, 
                values = map_data$median_age_male, 
                position = "bottomleft", 
                title = paste0("Median Age (Male)", "<br>", "(2018)"),
                opacity = 1.0)

```



```{r, echo=FALSE, message=FALSE}
#import pre-wrangled data
model_data <- read_csv("model_data.csv")
map_data <- read_csv("map_data.csv")

#scatterplot and model output for percent married households
ggplot(data = model_data, aes(x = pct_married_hh, y = pct_pop_change)) +
      geom_point(aes(color = region, size = population)) +
      geom_smooth(method = 'lm', se = FALSE) +
      labs(x = "Percent Married Couple Households"
           ,y = "Percent Population Change 2013-2018") +
      theme_bw()
summary(lm(pct_pop_change ~ pct_married_hh, data = model_data))
```




## Limitations

Probably the biggest limitation of our work is the small number of years for which we were able to gather data. Data from the American Community Survey is available via `tidycensus` from 2009 to 2018, but many areas were named differently by the ACS from 2009 to 2012. This presented a big enough obstacle to joining the data from these years that we decided to only include years 2013 to 2018. 

Even if we had compiled data from all ten years of the ACS, though, this would still only provide an incomplete picture of the way US Metropolitan Areas have changed over time. Ideally, we would be able to go back several decades and connect patterns in the data with longer-term historical developments (this would require some qualitative background research, which was also beyond the scope of this project). Perhaps in a future Shiny app, we could include data going back into the 20th century and let the user specify the start and end years of a time period they want to look at.

Our findings are also not necessarily generalizable. We only looked at the one hundred most populous metro areas in the country, which are probably not representative of all of urban and suburban America. A lot of areas on this list might have similar characteristics to say, the next 100 most populated cities and towns, but it is likely that the top cities like New York, Los Angeles and Chicago skew the data. In any case, the map we’ve created has a lot of empty space since most cities are concentrated on the coasts; states like Montana, North and South Dakota, Maine, West Virginia, and Alaska have no data, making it hard to draw conclusions about the spatial distribution of variables across the country.

Finally, our model does an imperfect job of answering our main question: what factors contribute to cities’ wellbeing? This component of our Shiny app uses population growth from 2013 to 2018 as a proxy for wellbeing, when this is obviously not the ultimate indicator of how successful a city is or how high a quality of life its residents have. And even if population growth were a perfect measure, the cities that grew the most from 2013 to 2018 are not necessarily the ones that are growing the fastest right now or even the ones that have grown the most over the past twenty or fifty years. Our question, of course, is incredibly complex, and the answer probably involves an interaction between a multitude of variables. Still, the interactivity of our Shiny app presents the user with a number of thought-provoking patterns and relationships, which, hopefully, will lead to more good questions.


## Bibliography
TidyCensus
Mdsr WorldCities


